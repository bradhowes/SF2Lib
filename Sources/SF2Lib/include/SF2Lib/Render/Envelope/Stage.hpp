// Copyright Â© 2022 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <iostream>
#include <limits>

#include "SF2Lib/DSP.hpp"

namespace SF2::Render::Envelope {

/// Stages defined in the SF2 2.01 spec (except for the `idle` state).
enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline StageIndex operator++(StageIndex value) noexcept {
  using IntType = typename std::underlying_type<StageIndex>::type;
  return static_cast<StageIndex>( static_cast<IntType>(value) + 1 );
}

inline const char* StageName(StageIndex stageIndex) noexcept {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
  }
}

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.

   @param durationInSamples number of samples to report out the constant value.
   */
  void setConstant(int durationInSamples) noexcept {
    durationInSamples_ = std::max(durationInSamples, 0);
    increment_ = 0.0;
  }

  /**
   Generate a configuration for the delay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setDelay(int durationInSamples) noexcept { setConstant(durationInSamples); }

  /**
   Generate a configuration for the attack stage. NOTE: there is always at least one sample in order to transition from
   0.0 to 1.0.

   @param durationInSamples number of samples to spend in this stage
   */
  void setAttack(int durationInSamples) noexcept {
    durationInSamples_ = std::max(durationInSamples, 1);
    increment_ = 1.0 / durationInSamples_;
  }

  /**
   Generate a configuration for the hold stage. This "holds" the envelope at a 1.0 value for a given number of samples
   before entering the decay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setHold(int durationInSamples) noexcept { setConstant(durationInSamples); }

  /**
   Generate a configuration for the decay stage. There is always at least 1 sample in this stage to support the
   transition from 1.0 to the sustainLevel.

   @param durationInSamples number of samples to spend in this stage
   @param sustainLevel the sustain level to descend to from 1.0 peak.
   */
  void setDecay(int durationInSamples, Float sustainLevel) noexcept {
    durationInSamples_ = std::max(durationInSamples, 1);
    if (durationInSamples_ == 1) {
      increment_ = sustainLevel - 1.0;
      return;
    }

    /*
     According to the spec, the duration for the decay stage is the amount of time that it takes to go from 1.0 to
     100 dB attenuation: "If the sustain level were -100dB, the Volume Envelope Decay Time would be the time spent in
     decay phase." This implies that the slope of the decay is based only on the duration, not on the sustain level.

     - First calculate the slope for a 1.0 - 0.0 descent over the given duration in samples
     - Calculate the actual duration to go from 1.0 to the sustain level
     - Recalculate the increment so that we reach the sustain level after the duration samples counts have passed.
     */
    Float span = (1.0 - sustainLevel);
    if (span == 0.0) {
      increment_ = 0.0;
      return;
    }

    Float increment = Float(-1.0) / Float(durationInSamples_);
    durationInSamples_ = std::max(static_cast<int>(floor(span / -increment)), 1);
    increment_ = (1.0 - sustainLevel) / -Float(durationInSamples_);
  }

  /**
   Generate a configuration for the sustain stage. This is the envelope level to report out while the envelope gate is
   true (MIDI key is down).
   */
  void setSustain() noexcept { setConstant(std::numeric_limits<int>::max()); }

  /**
   Generate a configuration for the release stage. The spec says that this is a 100% change in the volume envelope,
   going from 0 to -100dB attenuation if the sustain level is set to 0. Thus if sustainLevel (0.0-1.0) is non-zero,
   calculate the actual number of samples to spend in the stage to reach 0.0 envelope. Like the attack stage, there is
   always at least 1 sample in this stage so that we can transition from sustainLevel to 0.0.

   @param durationInSamples number of samples to spend in this stage
   */
  void setRelease(int durationInSamples) noexcept {
    durationInSamples_ = std::max(durationInSamples, 1);
    increment_ = -1.0 / durationInSamples_;
  }

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  constexpr Float next(Float last) const noexcept { return last + increment_; }

  /// @returns the increment to apply to reach the next envelope value
  constexpr Float increment() const noexcept { return increment_; }

  /// @returns the duration of the stage in samples
  constexpr int durationInSamples() const noexcept { return durationInSamples_; }

private:
  Float increment_{0.0};
  int durationInSamples_{0};
};

} // namespace SF2::Render::Envelope
