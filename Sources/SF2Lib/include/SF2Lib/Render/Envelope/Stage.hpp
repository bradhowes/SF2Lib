// Copyright Â© 2022 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <limits>

#include "SF2Lib/Types.hpp"

namespace SF2::Render::Envelope {

/// Stages defined in the SF2 2.01 spec (except for the `idle` state).
enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline const char* StageName(StageIndex stageIndex) noexcept {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
    default: throw "unknown stage value";
  }
}

class Generator;

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  inline static constexpr Float minimumCurvature = 1.0e-7f;
  inline static constexpr Float maximumCurvature = 10.0f;

  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.
   */
  static Stage Constant(int sampleCount, Float value) noexcept {
    return Stage(value, 1.0, 0.0, sampleCount);
  }

  /**
   Generate a configuration for the delay stage.
   */
  static Stage Delay(int sampleCount) noexcept { return Constant(sampleCount, 0.0); }

  /**
   Generate a configuration for the attack stage.
   */
  static Stage Attack(int sampleCount, Float curvature) noexcept {
    curvature = clampedCurvature(curvature);
    Float alpha = calculateAlphaCoefficient(sampleCount, curvature);
    return Stage(0.0f, alpha, (1.0f + curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Generate a configuration for the delay stage.
   */
  static Stage Hold(int sampleCount) noexcept { return Constant(sampleCount, 1.0f); }

  /**
   Generate a configuration for the decay stage.
   */
  static Stage Decay(int sampleCount, Float curvature, Float sustainLevel) noexcept {
    curvature = clampedCurvature(curvature);
    Float alpha = calculateAlphaCoefficient(sampleCount, curvature);
    return Stage(1.0f, alpha, (sustainLevel - curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Generate a configuration for the sustain stage.
   */
  static Stage Sustain(Float level) noexcept {
    return Constant(std::numeric_limits<uint16_t>::max(), level);
  }

  /**
   Generate a configuration for the release stage.
   */
  static Stage Release(int sampleCount, Float curvature, Float sustainLevel) noexcept {
    curvature = clampedCurvature(curvature);
    Float alpha = calculateAlphaCoefficient(sampleCount, curvature);
    return Stage(sustainLevel, alpha, (0.0f - curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  Float next(Float last) const noexcept { return std::max<Float>(std::min<Float>(last * alpha_ + beta_, 1.0), 0.0); }

  /// @returns initial envelope value for the stage
  Float initial() const noexcept { return initial_; }

  /// @returns the alpha curve parameter
  Float alpha() const noexcept { return alpha_; }

  /// @returns the beta curve parameter
  Float beta() const noexcept { return beta_; }

  /// @returns the duration of the stage in seconds
  int duration() const noexcept { return durationInSamples_; }
  
private:

  Stage(Float initial, Float alpha, Float beta, int durationInSamples) noexcept :
  initial_{initial}, alpha_{alpha}, beta_{beta}, durationInSamples_{durationInSamples} {}

  static Float clampedCurvature(Float curvature) noexcept {
    return DSP::clamp(curvature, minimumCurvature, maximumCurvature);
  }

  static Float calculateAlphaCoefficient(Float sampleCount, Float curvature) noexcept {
    curvature = clampedCurvature(curvature);
    return (sampleCount <= 0.0f) ? 0.0f : std::exp(-std::log((1.0f + curvature) / curvature) / sampleCount);
  }

  friend class Generator;

  Float initial_{0.0};
  Float alpha_{0.0};
  Float beta_{0.0};
  int durationInSamples_{0};
};

} // namespace SF2::Render::Envelope
