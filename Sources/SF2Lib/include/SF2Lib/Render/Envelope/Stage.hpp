// Copyright Â© 2022 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <limits>

#include "SF2Lib/DSP.hpp"

namespace SF2::Render::Envelope {

/// Stages defined in the SF2 2.01 spec (except for the `idle` state).
enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline StageIndex operator++(StageIndex value) noexcept {
  assert(value != StageIndex::release);
  using IntType = typename std::underlying_type<StageIndex>::type;
  return static_cast<StageIndex>( static_cast<IntType>(value) + 1 );
}

inline const char* StageName(StageIndex stageIndex) noexcept {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
    default: throw "unknown stage value";
  }
}

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.

   @param durationInSamples number of samples to report out the constant value.
   @param value the constant value to use
   */
  void setConstant(int durationInSamples, Float value) noexcept {
    setDurationInSamples(durationInSamples);
    initial_ = clamp(value);
    increment_ = 0.0;
  }

  /**
   Generate a configuration for the delay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setDelay(int durationInSamples) noexcept { setConstant(durationInSamples, 0.0); }

  /**
   Generate a configuration for the attack stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setAttack(int durationInSamples) noexcept {
    setDurationInSamples(durationInSamples);
    initial_ = 0.0;
    increment_ = calcIncrement(0.0, 1.0, durationInSamples_);
  }

  /**
   Generate a configuration for the hold stage. This "holds" the envelope at a 1.0 value for a given number of samples
   before entering the decay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setHold(int durationInSamples) noexcept { setConstant(durationInSamples, 1.0); }

  /**
   Generate a configuration for the decay stage.

   @param durationInSamples number of samples to spend in this stage
   @param sustainLevel the sustain level to descend to from 1.0 peak.
   */
  void setDecay(int durationInSamples, Float sustainLevel) noexcept {
    setDurationInSamples(durationInSamples);
    initial_ = 1.0;
    increment_ = calcIncrement(1.0, sustainLevel, durationInSamples);
  }

  /**
   Generate a configuration for the sustain stage. This is the envelope level to report out while the envelope gate is
   true (MIDI key is down).

   @param level the envelope value to report out during while the gate is active
   */
  void setSustain(Float level) noexcept { setConstant(std::numeric_limits<int>::max(), level); }

  /**
   Generate a configuration for the release stage. The spec says that this is a 100% change in the volume envelope,
   going from 0 to -100dB attenuation if the sustain level is set to 0. Thus if sustainLevel (0.0-1.0) is non-zero,
   calculate the actual number of samples to spend in the stage to reach 0.0 envelope.

   @param durationInSamples number of samples to spend in this stage
   @param sustainLevel the sustain level to descend from
   */
  void setRelease(int durationInSamples, Float sustainLevel) noexcept {
    setDurationInSamples(durationInSamples);
    initial_ = clamp(sustainLevel);
    increment_ = calcIncrement(sustainLevel, 0.0, durationInSamples);
  }

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  constexpr Float next(Float last) const noexcept { return clamp(last + increment_); }

  /// @returns initial envelope value for the stage
  constexpr Float initial() const noexcept { return initial_; }

  /// @returns the duration of the stage in samples
  constexpr int durationInSamples() const noexcept { return durationInSamples_; }

  void setDurationInSamples(int value) noexcept { durationInSamples_ = std::max(value, 0); }

private:

  static constexpr Float calcIncrement(Float start, Float end, int durationInSamples) noexcept {
    return durationInSamples ? (end - start) / Float(durationInSamples) : (end - start);
  }

  static constexpr Float clamp(Float value) noexcept { return DSP::clamp(value, 0.0f, 1.0f); }

  Float initial_{0.0};
  Float increment_{0.0};
  int durationInSamples_{0};
};

} // namespace SF2::Render::Envelope
