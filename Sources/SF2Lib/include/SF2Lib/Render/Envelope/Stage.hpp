// Copyright Â© 2022 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <iostream>
#include <limits>

#include "SF2Lib/DSP.hpp"

namespace SF2::Render::Envelope {

/// Stages defined in the SF2 2.01 spec (except for the `idle` state).
enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline StageIndex operator++(StageIndex value) noexcept { return static_cast<StageIndex>(SF2::valueOf(value) + 1); }

inline const char* StageName(StageIndex stageIndex) noexcept {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
  }
}

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.

   @param durationInSamples number of samples to report out the constant value.
   */
  void setConstant(int durationInSamples) noexcept;

  /**
   Generate a configuration for the delay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setDelay(int durationInSamples) noexcept { setConstant(durationInSamples); }

  /**
   Generate a configuration for the attack stage. NOTE: there is always at least one sample in order to transition from
   0.0 to 1.0.

   @param durationInSamples number of samples to spend in this stage
   */
  void setAttack(int durationInSamples) noexcept;

  /**
   Generate a configuration for the hold stage. This "holds" the envelope at a 1.0 value for a given number of samples
   before entering the decay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setHold(int durationInSamples) noexcept { setConstant(durationInSamples); }

  /**
   Generate a configuration for the decay stage. There is always at least 1 sample in this stage to support the
   transition from 1.0 to the sustainLevel.

   @param sustainLevel the sustain level to descend to from 1.0 peak.
   @param durationInSamples number of samples to spend in this stage
   */
  void setDecay(Float sustainLevel, int durationInSamples) noexcept;

  /**
   Generate a configuration for the sustain stage. This is the envelope level to report out while the envelope gate is
   true (MIDI key is down).
   */
  void setSustain() noexcept { setConstant(std::numeric_limits<int>::max()); }

  /**
   Generate a configuration for the release stage. The spec says that this is a 100% change in the volume envelope,
   going from 0 to -100dB attenuation if the sustain level is set to 0. Thus if sustainLevel (0.0-1.0) is non-zero,
   calculate the actual number of samples to spend in the stage to reach 0.0 envelope. Like the attack stage, there is
   always at least 1 sample in this stage so that we can transition from sustainLevel to 0.0.

   @param durationInSamples number of samples to spend in this stage
   */
  void setRelease(int durationInSamples) noexcept;

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  Float next(Float last) const noexcept { return last + increment_; }

  /// @returns the increment to apply to reach the next envelope value
  Float increment() const noexcept { return increment_; }

  /// @returns the duration of the stage in samples
  int durationInSamples() const noexcept { return durationInSamples_; }

private:
  Float increment_{0.0};
  int durationInSamples_{0};
};

} // namespace SF2::Render::Envelope
