// Copyright Â© 2022 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <limits>

#include "SF2Lib/DSP.hpp"

namespace SF2::Render::Envelope {

/// Stages defined in the SF2 2.01 spec (except for the `idle` state).
enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline const char* StageName(StageIndex stageIndex) noexcept {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
    default: throw "unknown stage value";
  }
}

class Generator;

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.

   @param durationInSamples number of samples to report out the constant value.
   @param value the constant value to use
   */
  void setConstant(int durationInSamples, Float value) noexcept {
    durationInSamples_ = std::max(durationInSamples, 0);
    initial_ = DSP::clamp(value, 0.0, 1.0);
    increment_ = 0.0;
  }

  /**
   Generate a configuration for the delay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setDelay(int durationInSamples) noexcept { setConstant(durationInSamples, 0.0); }

  /**
   Generate a configuration for the attack stage. The spec implies that this is a transition from -100dB to 0dB
   attenuation. Here, it is a transition of 0.0 to 1.0. However, the Generator will square the resulting value for
   the attack stage which will result in an exponential curve for the attack.

   @param durationInSamples number of samples to spend in this stage
   */
  void setAttack(int durationInSamples) noexcept {
    durationInSamples_ = std::max(durationInSamples, 0);
    initial_ = 0.0;
    increment_ = calcIncrement(0.0, 1.0, durationInSamples_);
  }

  inline static Float calcIncrement(Float start, Float end, int durationInSamples) noexcept {
    return durationInSamples > 0 ? ((end - start) / Float(durationInSamples)) : 0.0;
  }

  inline static int calcDuration(Float start, Float end, Float increment) noexcept {
    return increment != 0.0 ? static_cast<int>(std::nearbyint((end - start) / increment)) : 0;
  }

  /**
   Generate a configuration for the hold stage. This "holds" the envelope at a 1.0 value for a given number of samples
   before entering the decay stage.

   @param durationInSamples number of samples to spend in this stage
   */
  void setHold(int durationInSamples) noexcept { setConstant(durationInSamples, 1.0); }

  /**
   Generate a configuration for the decay stage. The spec says that this is a 100% change in the volume envelope, going
   from 0 to -100dB attenuation if the sustain level is set to 0. Thus if sustainLevel (0.0-1.0) is non-zero,
   calculate the actual number of samples to spend in the stage to reach the given sustain level.

   @param durationInSamples number of samples to spend in this stage
   @param sustainLevel the sustain level to descend to from 1.0 peak.
   */
  void setDecay(int durationInSamples, Float sustainLevel) noexcept {
    initial_ = 1.0;
    increment_ = calcIncrement(1.0, sustainLevel, durationInSamples);
    durationInSamples_ = calcDuration(1.0, sustainLevel, increment_);
  }

  /**
   Generate a configuration for the sustain stage. This is the envelope level to report out while the envelope gate is
   true (MIDI key is down).

   @param level the envelope value to report out during while the gate is active
   */
  void setSustain(Float level) noexcept { setConstant(std::numeric_limits<int>::max(), level); }

  /**
   Generate a configuration for the release stage. The spec says that this is a 100% change in the volume envelope,
   going from 0 to -100dB attenuation if the sustain level is set to 0. Thus if sustainLevel (0.0-1.0) is non-zero,
   calculate the actual number of samples to spend in the stage to reach 0.0 envelope.

   @param durationInSamples number of samples to spend in this stage
   @param sustainLevel the sustain level to descend from
   */
  void setRelease(int durationInSamples, Float sustainLevel) noexcept {
    initial_ = DSP::clamp(sustainLevel, 0.0, 1.0);
    increment_ = calcIncrement(sustainLevel, 0.0, durationInSamples);
    durationInSamples_ = calcDuration(sustainLevel, 0.0, increment_);
  }

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  Float next(Float last) const noexcept { return DSP::clamp(last + increment_, 0.0, 1.0); }

  /// @returns initial envelope value for the stage
  Float initial() const noexcept { return initial_; }

  /// @returns the duration of the stage in samples
  int durationInSamples() const noexcept { return durationInSamples_; }

private:

  // friend class Generator;

  Float initial_{0.0};
  Float increment_{0.0};
  int durationInSamples_{0};
};

} // namespace SF2::Render::Envelope
